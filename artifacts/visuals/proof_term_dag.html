<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Proof Term DAG - Futamura-Adelic</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      font-family: 'SF Mono', 'Monaco', 'Inconsolata', 'Fira Code', monospace;
      background: #000;
      color: #fff;
      min-height: 100vh;
    }
    .header {
      background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
      padding: 20px;
      border-bottom: 1px solid #8b5cf6;
    }
    .header h1 {
      font-size: 1.5rem;
      color: #a78bfa;
      margin-bottom: 8px;
    }
    .header p {
      color: #9ca3af;
      font-size: 0.875rem;
    }
    .container {
      display: flex;
      height: calc(100vh - 100px);
    }
    .sidebar {
      width: 280px;
      background: #111827;
      border-right: 1px solid #374151;
      overflow-y: auto;
    }
    .theorem-item {
      padding: 15px;
      border-bottom: 1px solid #374151;
      cursor: pointer;
      transition: background 0.2s;
    }
    .theorem-item:hover {
      background: #1f2937;
    }
    .theorem-item.active {
      background: #6d28d9;
    }
    .theorem-item h3 {
      color: #a78bfa;
      font-size: 0.9rem;
      margin-bottom: 4px;
    }
    .theorem-item p {
      color: #9ca3af;
      font-size: 0.75rem;
    }
    .main {
      flex: 1;
      display: flex;
      flex-direction: column;
    }
    .info-bar {
      background: #111827;
      padding: 15px 20px;
      border-bottom: 1px solid #374151;
    }
    .info-bar h2 {
      color: #a78bfa;
      font-size: 1rem;
      margin-bottom: 5px;
    }
    .info-bar .term-structure {
      color: #c4b5fd;
      font-size: 0.8rem;
      font-family: 'SF Mono', monospace;
      background: #1f2937;
      padding: 10px 14px;
      border-radius: 6px;
      margin-top: 10px;
      border-left: 3px solid #8b5cf6;
    }
    .graph-container {
      flex: 1;
      position: relative;
      overflow: auto;
      background: radial-gradient(circle at 50% 50%, #0c0a1d 0%, #000 100%);
    }
    .graph-svg {
      min-width: 100%;
      min-height: 100%;
    }
    .node {
      cursor: pointer;
      transition: transform 0.2s, opacity 0.2s;
    }
    .node:hover {
      transform: scale(1.08);
    }
    .node-shape {
      stroke-width: 2;
    }
    .node-text {
      font-size: 11px;
      fill: #fff;
      font-family: 'SF Mono', monospace;
      text-anchor: middle;
      dominant-baseline: middle;
    }
    .edge {
      stroke: #6b7280;
      stroke-width: 1.5;
      fill: none;
      marker-end: url(#arrowhead);
    }
    .legend {
      position: absolute;
      bottom: 20px;
      right: 20px;
      background: rgba(17, 24, 39, 0.95);
      padding: 15px;
      border-radius: 8px;
      border: 1px solid #374151;
    }
    .legend h4 {
      color: #a78bfa;
      font-size: 0.75rem;
      margin-bottom: 10px;
    }
    .legend-item {
      display: flex;
      align-items: center;
      margin-bottom: 6px;
      font-size: 0.7rem;
    }
    .legend-color {
      width: 16px;
      height: 16px;
      border-radius: 4px;
      margin-right: 8px;
    }
    .controls {
      position: absolute;
      top: 20px;
      right: 20px;
      background: rgba(17, 24, 39, 0.95);
      padding: 10px;
      border-radius: 8px;
      border: 1px solid #374151;
    }
    .controls button {
      background: #4c1d95;
      color: #fff;
      border: none;
      padding: 8px 12px;
      margin: 2px;
      border-radius: 4px;
      cursor: pointer;
      font-size: 0.75rem;
    }
    .controls button:hover {
      background: #6d28d9;
    }
    .tooltip {
      position: absolute;
      background: rgba(17, 24, 39, 0.98);
      border: 1px solid #a78bfa;
      border-radius: 6px;
      padding: 12px;
      max-width: 350px;
      font-size: 0.75rem;
      pointer-events: none;
      z-index: 1000;
      display: none;
    }
    .tooltip .type-badge {
      display: inline-block;
      padding: 2px 8px;
      border-radius: 4px;
      font-size: 0.65rem;
      margin-bottom: 6px;
    }
  </style>
</head>
<body>
  <div class="header">
    <h1>Proof Term DAG</h1>
    <p>Abstract syntax tree visualization of proof term structure</p>
  </div>

  <div class="container">
    <div class="sidebar" id="theoremList"></div>

    <div class="main">
      <div class="info-bar" id="infoBar">
        <h2 id="theoremName">Select a theorem</h2>
        <p id="theoremDesc"></p>
        <div class="term-structure" id="termStructure" style="display: none;"></div>
      </div>

      <div class="graph-container" id="graphContainer">
        <svg class="graph-svg" id="graphSvg">
          <defs>
            <marker id="arrowhead" markerWidth="8" markerHeight="6" refX="7" refY="3" orient="auto">
              <polygon points="0 0, 8 3, 0 6" fill="#6b7280"/>
            </marker>
          </defs>
        </svg>

        <div class="controls">
          <button onclick="zoomIn()">Zoom +</button>
          <button onclick="zoomOut()">Zoom -</button>
          <button onclick="resetView()">Reset</button>
        </div>
      </div>

      <div class="legend">
        <h4>Term Types</h4>
        <div class="legend-item"><div class="legend-color" style="background: #3b82f6;"></div> Application</div>
        <div class="legend-item"><div class="legend-color" style="background: #8b5cf6;"></div> Lambda</div>
        <div class="legend-item"><div class="legend-color" style="background: #22c55e;"></div> Variable</div>
        <div class="legend-item"><div class="legend-color" style="background: #f59e0b;"></div> Constant</div>
        <div class="legend-item"><div class="legend-color" style="background: #06b6d4;"></div> Equality</div>
        <div class="legend-item"><div class="legend-color" style="background: #ec4899;"></div> Constructor</div>
        <div class="legend-item"><div class="legend-color" style="background: #14b8a6;"></div> Calc Block</div>
      </div>
    </div>
  </div>

  <div class="tooltip" id="tooltip"></div>

  <script src="proof_term_data.js"></script>
  <script>
    const svg = document.getElementById('graphSvg');
    const theoremList = document.getElementById('theoremList');
    const tooltip = document.getElementById('tooltip');

    let currentTheorem = null;
    let scale = 1;

    // Populate theorem list
    proofTermData.theorems.forEach((thm, idx) => {
      const item = document.createElement('div');
      item.className = 'theorem-item' + (idx === 0 ? ' active' : '');
      item.innerHTML = `
        <h3>${thm.name}</h3>
        <p>${thm.description}</p>
      `;
      item.onclick = () => selectTheorem(thm, item);
      theoremList.appendChild(item);
    });

    function selectTheorem(thm, element) {
      document.querySelectorAll('.theorem-item').forEach(el => el.classList.remove('active'));
      element.classList.add('active');
      currentTheorem = thm;

      document.getElementById('theoremName').textContent = thm.name;
      document.getElementById('theoremDesc').textContent = thm.description;
      document.getElementById('termStructure').textContent = thm.termStructure;
      document.getElementById('termStructure').style.display = 'block';

      renderDAG(thm);
    }

    function renderDAG(thm) {
      // Clear existing
      svg.innerHTML = `
        <defs>
          <marker id="arrowhead" markerWidth="8" markerHeight="6" refX="7" refY="3" orient="auto">
            <polygon points="0 0, 8 3, 0 6" fill="#6b7280"/>
          </marker>
        </defs>
        <g id="graphGroup" transform="scale(${scale})"></g>
      `;

      const graphGroup = document.getElementById('graphGroup');
      const nodeWidth = 140;
      const nodeHeight = 36;
      const levelGapX = 180;
      const levelGapY = 70;
      const startX = 80;
      const startY = 50;

      // Tree layout: calculate positions
      const nodePositions = {};
      const depthCounts = {};
      const depthIndices = {};

      // Count nodes at each depth
      thm.nodes.forEach(n => {
        depthCounts[n.depth] = (depthCounts[n.depth] || 0) + 1;
      });

      // Position nodes in a tree layout
      thm.nodes.forEach(n => {
        depthIndices[n.depth] = depthIndices[n.depth] || 0;
        const count = depthCounts[n.depth];
        const idx = depthIndices[n.depth]++;

        // Horizontal tree layout
        const x = startX + n.depth * levelGapX;
        const totalHeight = count * (nodeHeight + 25);
        const startOffset = -totalHeight / 2 + nodeHeight / 2;
        const y = 250 + startOffset + idx * (nodeHeight + 25);

        nodePositions[n.id] = { x, y, node: n };
      });

      // Draw edges first (so they're behind nodes)
      thm.edges.forEach(e => {
        const from = nodePositions[e.from];
        const to = nodePositions[e.to];
        if (!from || !to) return;

        const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
        const startX = from.x + nodeWidth;
        const startY = from.y + nodeHeight / 2;
        const endX = to.x;
        const endY = to.y + nodeHeight / 2;
        const midX = (startX + endX) / 2;

        path.setAttribute('d', `M ${startX} ${startY} C ${midX} ${startY}, ${midX} ${endY}, ${endX} ${endY}`);
        path.setAttribute('class', 'edge');
        graphGroup.appendChild(path);
      });

      // Draw nodes
      thm.nodes.forEach(n => {
        const pos = nodePositions[n.id];
        const g = document.createElementNS('http://www.w3.org/2000/svg', 'g');
        g.setAttribute('class', 'node');
        g.setAttribute('transform', `translate(${pos.x}, ${pos.y})`);

        const color = proofTermData.nodeColors[n.type] || '#374151';

        // Draw shape based on type
        let shape;
        if (n.type === 'lam') {
          // Diamond for lambda
          shape = document.createElementNS('http://www.w3.org/2000/svg', 'polygon');
          const hw = nodeWidth / 2, hh = nodeHeight / 2;
          shape.setAttribute('points', `${hw},0 ${nodeWidth},${hh} ${hw},${nodeHeight} 0,${hh}`);
        } else if (n.type === 'var') {
          // Ellipse for variables
          shape = document.createElementNS('http://www.w3.org/2000/svg', 'ellipse');
          shape.setAttribute('cx', nodeWidth / 2);
          shape.setAttribute('cy', nodeHeight / 2);
          shape.setAttribute('rx', nodeWidth / 2);
          shape.setAttribute('ry', nodeHeight / 2);
        } else {
          // Rectangle for others
          shape = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
          shape.setAttribute('width', nodeWidth);
          shape.setAttribute('height', nodeHeight);
          shape.setAttribute('rx', 6);
          shape.setAttribute('ry', 6);
        }

        shape.setAttribute('class', 'node-shape');
        shape.setAttribute('fill', color);
        shape.setAttribute('stroke', color);

        const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
        text.setAttribute('x', nodeWidth / 2);
        text.setAttribute('y', nodeHeight / 2);
        text.setAttribute('class', 'node-text');

        // Truncate long labels
        const maxLen = 18;
        const label = n.label.length > maxLen ? n.label.substring(0, maxLen) + 'â€¦' : n.label;
        text.textContent = label;

        g.appendChild(shape);
        g.appendChild(text);

        // Tooltip
        g.onmouseenter = (e) => {
          tooltip.innerHTML = `
            <div class="type-badge" style="background: ${color}">${n.type.toUpperCase()}</div>
            <div style="margin-top: 6px; color: #e5e7eb;">${n.label}</div>
          `;
          tooltip.style.display = 'block';
          tooltip.style.left = (e.pageX + 15) + 'px';
          tooltip.style.top = (e.pageY + 15) + 'px';
        };
        g.onmouseleave = () => {
          tooltip.style.display = 'none';
        };

        graphGroup.appendChild(g);
      });

      // Adjust SVG size
      const maxX = Math.max(...Object.values(nodePositions).map(p => p.x)) + nodeWidth + 100;
      const maxY = Math.max(...Object.values(nodePositions).map(p => p.y)) + nodeHeight + 100;
      const minY = Math.min(...Object.values(nodePositions).map(p => p.y)) - 50;
      svg.setAttribute('width', maxX * scale);
      svg.setAttribute('height', (maxY - minY + 100) * scale);
    }

    function zoomIn() {
      scale = Math.min(scale * 1.2, 2);
      if (currentTheorem) renderDAG(currentTheorem);
    }

    function zoomOut() {
      scale = Math.max(scale / 1.2, 0.5);
      if (currentTheorem) renderDAG(currentTheorem);
    }

    function resetView() {
      scale = 1;
      if (currentTheorem) renderDAG(currentTheorem);
    }

    // Select first theorem by default
    if (proofTermData.theorems.length > 0) {
      selectTheorem(proofTermData.theorems[0], document.querySelector('.theorem-item'));
    }
  </script>
</body>
</html>
